Когда поток запрашивает lock, которым уже владеет другой поток, он
блокирует продвижение. Но так как внутренние locks являются повторно входимыми (reentrant), 
то запрос выполнится успешно. Без повторно входимых locks 
код был бы заперт взаимной блокировкой (deadlock), а вызов `super.doSomething` никогда не смог бы
приобрести lock, считающийся занятым.