Когда поток запрашивает lock, которым уже владеет другой поток, он
блокирует продвижение. Но так как внутренние locks являются повторно входимыми (reentrant), 
если поток пытается приобрести lock,
которым он уже владеет, то запрос выполнится успешно. Повторная
входимость означает, что locks приобретаются в расчете на один поток,
а не в расчете на один вызов, путем ассоциирования потоков с locks. Без повторно входимых locks 
код был бы заперт взаимной блокировкой (deadlock), а вызов `super.doSomething` никогда не смог бы
приобрести lock, считающийся занятым.