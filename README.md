<details>
<summary>
Глоссарий
</summary>

---

#### Атомарные операции (atomic operations)

Операции A и B являются атомарными, если, с точки зрения потока,
выполняющего операцию A, операция B либо была целиком выполнена
другим потоком, либо не выполнена даже частично.

---

#### Составные действия (compound actions)

Последовательность операций, которые должны выполняться
атомарно, чтобы оставаться потокобезопасными.

---

#### Мониторный/внутренний замок (monitor/intrinsic lock)

Java предоставляет встроенный замковый механизм для усиления
атомарности — синхронизированный блок, состоящий из ссылки на
объект-замок (lock) и блока кода, который будет им защищен. 
Ключевое слово `synchronized` является условным обозначением и метода,
и замка. Статические синхронизированные методы используют объект
`Class`.

```java
synchronized (lock) {
// Обратиться к защищаемому замком совместному состоянию либо его изменить
}
```

Каждый объект Java может неявно действовать как замок для целей
синхронизации, то есть являться внутренним замком (intrinsic lock)
или мониторным замком (monitor lock). Замок автоматически приобретается выполняющим потоком 
перед входом в синхронизированный блок и автоматически освобождается, когда управление выходит из
синхронизированного блока: либо обычным путем выполнения кода,
либо путем исключения из блока. Приобрести внутренний замок можно
только при входе в синхронизированный блок или в метод, защищенный
этим замком.

---

#### Мьютекс (mutex)

Внутренние замки в Java действуют как взаимоисключающие замки —
мьютексы (mutual exclusion locks). Это означает, что замком может владеть не более чем один поток. Когда поток А пытается приобрести замок,
которым владеет поток В, он должен ждать или блокировать продвижение
до тех пор, пока В его не освободит. Если В не освободит замок никогда,
то А будет ждать вечно. Поскольку только один поток за раз может выполнять блок кода, 
защищенный замком, синхронизированные блоки, защищенные тем же замком,
выполняются атомарно. Никакой поток, выполняющий синхронизированный блок, не может наблюдать другой поток в синхронизированном
блоке, защищенном тем же замком.

---

#### Повторно входимые внутренние замки (reentrant intrinsic lock)

Когда поток запрашивает `lock`, которым уже владеет другой поток, он
блокирует продвижение. Но так как внутренние `locks` являются повторно входимыми (reentrant),
если поток пытается приобрести `lock`,
которым он уже владеет, то запрос выполнится успешно. Повторная
входимость означает, что `locks` приобретаются в расчете на один поток,
а не в расчете на один вызов, путем ассоциирования потоков с `locks`.

---

#### Volatile-переменные

Язык Java также предоставляет альтернативную, более слабую форму
синхронизации — использование volatile-переменных, обновления
которых распространяются предсказуемо всеми потоками. Переменная
`volatile` для компилятора и рабочей среды является совместной, то есть
операции над ней не будут переупорядочены с другими операциями в памяти. Volatile-переменные
не кэшируются в регистрах или кэшах, где данные скрыты от других процессоров, 
поэтому их чтение всегда возвращает самый последний результат операций записи.
Обращение к volatile-переменной не может побудить выполняющий поток к блокированию, 
что делает ее легковесным механизмом синхронизации.

---

#### Безопасность из ниоткуда

Когда поток читает переменную без синхронизации, он может увидеть
устаревшее значение, но можно утверждать, что это значение было помещено туда каким-то потоком,
а не возникло случайно. Эта гарантия безопасности называется _безопасностью из ниоткуда_.

Она применима ко всем переменным с одним исключением: 64-разрядные числовые переменные 
(с типом double и long), которые не объявлены `volatile`. Модель памяти Java требует,
чтобы операции доставки из памяти и сохранения в память были атомарными, но переменным типов
`double` и `long` разрешено воспринимать 64-разрядное чтение и запись как две отдельные 32-разрядные
операции. Если чтения и записи происходят в разных потоках, то при чтении переменной `long`
можно получить назад верхние 32 бита одного значения и нижние 32 бита другого. Таким образом,
использовать в многопоточных программах совместные `mutable` переменные с типом
`double` и `long` небезопасно, если они не объявлены `volatile` или не защищены замком.

---

####  Публикация (publishing) объекта
Это означает его доступность за пределами текущей области действия. Например, ссылка на объект
может позволить другому коду вернуть его из неприватного метода или передать его методу
в другом классе. Публикация переменных внутреннего состояния препятствует инкапсуляции и
соблюдению инвариантов, а публикация объектов до момента их полного конструирования ставит
под угрозу потокобезопасность.

Самая простая форма публикации — это ссылка в публичном статическом поле. 
Метод `initialize` создает и публикует экземпляр нового хеш-множества, сохраняя ссылку
на него в `secrets`.

```java
public static Set<Secret> secrets;

public void initializeO {
    secrets = new HashSet<>();
}
```

Публикация одного объекта может косвенно публиковать другие. Если вы добавите Secret
в опубликованное множество `secrets`, то дополнение также опубликуется, 
потому что любой код может выполнить итеративный обход множества и получить ссылку
на новый Secret.


Еще одним механизмом публикации объекта или его внутреннего состояния является публикация
экземпляра внутреннего класса. Когда класс `ThisEscape` публикует слушателя `EventListener`,
он неявно публикует и окаймляющий его экземпляр `ThisEscape`, потому что экземпляры
внутреннего класса содержат скрытую ссылку на него.

```java
@NotThreadSafe
public class ThisEscape {
    
    public ThisEscape(EventSource source) {
        source.registerListener(
            new EventListener() {
                public void onEvent(Event e) {
                    doSomething(e);
                }
            });
    }
}
```

```java
@ThreadSafe
public class SafeListener {

    private final EventListener listener;

    private SafeListener() {
        listener = new EventListener() {
            public void onEvent(Event e) {
                doSomething(e);
            }
        };
    }

    public static SafeListener newInstance(Eventsource source) {
        SafeListener safe = new SafeListener();
        source.registerListener(safe.listener);
        return safe;
    }
}
```

---

#### Ускользнувший (escaped) объект

Объект, который не вовремя публикуется.

---

</details>



<details>
<summary>
Рекомендации
</summary>

---

Для сохранения непротиворечивости состояний обновляйте состояния родственных
переменных в единой атомарной операции.

```java
@NotThreadSafe
public class NumberTracker {
    
    private int previousNumber;
    private int currentNumber;
    
    public void updateNumber(int number) {
        previousNumber = currentNumber;
        currentNumber = number;
    }
}
```

```java
@ThreadSafe
public class NumberTracker {
    
    private int previousNumber;
    private int currentNumber;
    
    public synchronized void updateNumber(int number) {
        previousNumber = currentNumber;
        currentNumber = number;
    }
}
```

---

Избегайте удержания блокировки во время длительных вычислений или
операций, таких как сетевой или консольный ввод-вывод.

```java
@ThreadSafe
@UnnacceptablyPoorConcurrency
public class Something {
    
    private int count;
    
    public synchronized void simulateLongOperation() {
        // code
        count++;
        // code
    }
}
```

---

Чтобы обеспечить видимость актуальных значений совместных переменных, 
синхронизируйте читающие и пишущие потоки на общем замке.

---

Не позволяйте ссылке `this` ускользнуть во время конструирования.

Распространенной ошибкой, позволяющей ссылке `this` ускользнуть,
является запуск потока из конструктора. Когда объект создает поток из
своего конструктора, он почти всегда делится своей ссылкой `this` с новым
потоком, явно или неявно. Тогда новый поток видит владеющий объект
до своего окончательного конструирования. Нет ничего плохого в создании потока в конструкторе, но лучше
не запускать поток сразу. Вместо этого добавьте метод start или initialize, запускающий собственный поток.
Это позволит делиться объектом, построение которого гарантированно завершено.

```java
@NotThreadSafe
public class ThreadExecutorService {
    
    private ExecutorService executor;

    public ThreadExecutorService() {
        this.executor = Executors.newSingleThreadExecutor();
        executor.execute(this::doSomething);
    }
    
    private void doSomething() {
        // code
    }
}
```

```java
@ThreadSafe
public class ThreadExecutorService {
    
    private ExecutorService executor;

    public ThreadExecutorService() {
        this.executor = Executors.newSingleThreadExecutor();
    }

    public void start() {
        executor.execute(this::doSomething);
    }

    private void doSomething() {
        // code
    }
}
```

---

</details>