Простого сохранения объектной ссылки в публичном поле недостаточно, для того чтобы
опубликовать объект безопасно.

```java
// Небезопасная публикация
public Holder unsafeHolder;

public void initialize() {
    unsafeHolder = new Holder(42);
}
```

Из-за проблем видимости объект `Holder` может показаться другому потоку в противоречивом состоянии,
даже если его инварианты были правильно установлены его конструктором. Именно ненадлежащая публикация
заставит другой поток наблюдать частично сконструированный объект.

Проблема здесь не в самом классе `Holder`, а в его публикации. `Holder` может быть сделан
невосприимчивым к ненадлежащей публикации, если объявить поле n `final`, что сделает
класс `Holder` immutable.

Поскольку синхронизация не использовалась для того, чтобы сделать
класс `Holder` видимым для других потоков, другие потоки увидят либо
устаревшее значение в поле `unsafeHolder` (пустую ссылку null или другое),
либо актуальное значение ссылки на `unsafeHolder`, но устаревшие значения
состояния `Holder`, либо устаревшее значение при первом чтении поля,
а в следующий раз — более актуальное значение.

Можно предположить, что значения полей, заданные в конструкторе, являются
первыми значениями, записанными в эти поля, и увидеть в них устаревшие
значения невозможно. Но в действительности до начала работы конструкторов
подклассов конструктор `Object` записывает во все поля значения по умолчанию.
В случае, когда поле указано как `final`, такого поведения не происходит.
Ссылка на объект опубликуется только после завершения инициализации.