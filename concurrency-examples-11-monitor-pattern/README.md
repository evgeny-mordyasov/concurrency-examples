Класс `PersonSet` демонстрирует, как ограничение одним
экземпляром и блокировка работают вместе. Состояние объекта `PersonSet`
управляется непотокобезопасным объектом `HashSet`. Но `persons` является
приватным и не может ускользнуть, поэтому объект `HashSet` ограничен
объектом `PersonSet`. Единственными ветвями кода, которые могут обратиться к `persons`,
являются методы `addPerson` и `containsPerson`, и каждый
из них приобретает lock на `PersonSet`, состояние которого защищено
его внутренним lock.

По принципу ограничения одним экземпляром работает и мониторный
шаблон (monitor pattern): объект, подчиняющийся шаблону,
инкапсулирует mutable состояние под защитой внутреннего lock.

В классе `Counter` представлен пример работы шаблона: класс инкапсулирует одну переменную состояния, `value`,
и весь доступ к переменной состояния осуществляется через методы объекта `Counter`, поддерживая синхронизацию.

Вместо мониторного шаблона, который является просто соглашением, для защиты состояния объекта можно использовать другой 
замковый объект, например, приватный lock, как показано в классе `PrivateLock`.

Преимущество использования приватного замка — в его инкапсуляции,
которая не позволяет клиентскому коду приобрести его и участвовать
в политике его синхронизации, избавляя от необходимости проверки
всей программы.